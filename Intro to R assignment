## Question-1
# Set the file path to your sequence file
file_path <- "C:/Users/kdivy/.ipynb_checkpoints/chr1_GL383518v1_alt.fa"

# Read the sequence file, skipping the first line in FASTA files
sequence_lines <- readLines(file_path)[-1]

# Concatenate all lines into a single string for the complete DNA sequence
sequence <- paste(sequence_lines, collapse = "")

# Print the 10th letter of the sequence
cat("10th letter of the sequence:", substr(sequence, 10, 10), "\n")

# Print the 758th letter of the sequence
cat("758th letter of the sequence:", substr(sequence, 758, 758), "\n")


## Question-2
# Set the file path to your sequence file
file_path <- "C:/Users/kdivy/.ipynb_checkpoints/chr1_GL383518v1_alt.fa"

# Read and process the sequence
# readLines reads all lines from the file, and warn = FALSE suppresses warnings about incomplete final lines
# [-1] removes the first line, which is typically a header line in FASTA files
# paste combines the remaining lines into a single string
sequence <- paste(readLines(file_path, warn = FALSE)[-1], collapse = "")

# Convert the entire sequence to uppercase to standardize the nucleotide representation
sequence <- toupper(sequence)

# Generate the reverse complement
# chartr replaces each base with its complement: A <-> T and C <-> G
# strsplit splits the string into individual characters
# rev reverses the order of the characters
# paste combines the reversed characters back into a single string
reverse_complement <- paste(rev(strsplit(chartr("ATCG", "TAGC", sequence), NULL)[[1]]), collapse = "")

# substring extracts the 79th letter from the reverse complement sequence
cat("The 79th letter of the reverse complement sequence is:", substring(reverse_complement, 79, 79), "\n")
# substring extracts the letters from the 500th to the 800th position of the reverse complement sequence
cat("The 500th to 800th letters of the reverse complement sequence are:\n", substring(reverse_complement, 500, 800), "\n")


## Question-3
# Set the file path to your sequence file
file_path <- "C:/Users/kdivy/.ipynb_checkpoints/chr1_GL383518v1_alt.fa"

# Read the sequence from the file
# readLines reads all lines from the file
# grepl("^>") identifies header lines that start with ">", and filter these out
# do.call(paste0, as.list(...)) concatenates the remaining lines into a single string (the DNA sequence)
sequence <- do.call(paste0, as.list(readLines(file_path)[!grepl("^>", readLines(file_path))]))

# Calculate the number of chunks (kilobases) needed
# Each kilobase is 1000 base pairs, so we divide the total length of the sequence by 1000 and round up
chunks <- ceiling(nchar(sequence) / 1000)

# Create a list to store counts of nucleotides for each kilobase
# Extract a substring of 1000 characters from the sequence
# Split into individual characters and convert them into a list of single characters
# 'factor' ensures we count only levels specified (A, C, G, T) even if not all are present
counts_list <- lapply(1:chunks, function(i) table(factor(strsplit(substr(sequence, (i-1)*1000 + 1, min(i*1000, nchar(sequence))), "")[[1]], levels = c("A", "C", "G", "T"))))

# Name each element of the list based on the chunk number
names(counts_list) <- paste0("Kilobase_", 1:chunks)

# Display the list of counts, where each element shows counts of A, C, G, and T
counts_list


## Question-4
## 4-a
# Count occurrences of nucleotides in the first 1000 base pairs
first_kilobase_counts <- counts_list[[1]]

# Create a data frame with columns for each nucleotide count
# The data frame will have one row with counts for A, C, G, and T
df <- data.frame(
  A = first_kilobase_counts["A"],
  C = first_kilobase_counts["C"],
  G = first_kilobase_counts["G"],
  T = first_kilobase_counts["T"]
)

# Display the data frame
print(df)


## 4-b
# Initialize a data frame to hold counts for each kilobase
# Use lapply to iterate over each element in counts_list and create a data frame for each kilobase
kilobase_df <- do.call(rbind, lapply(1:length(counts_list), function(i) {
  counts <- counts_list[[i]]  # Get counts for the current kilobase

# Create a data frame for the current kilobase with nucleotide counts
  data.frame(
    Kilobase = paste0("Kilobase_", i),
    A = counts["A"],
    C = counts["C"],
    G = counts["G"],
    T = counts["T"]
  )
}))
# Display the resulting data frame
print(kilobase_df)


## 4-c
# Create a single row data frame for each kilobase's counts and combine them
combined_df <- do.call(rbind, lapply(1:length(counts_list), function(i) {
  counts <- counts_list[[i]]  # Get counts for the current kilobase
  data.frame(
    Kilobase = paste0("Kilobase_", i),
    A = as.numeric(counts["A"]),
    C = as.numeric(counts["C"]),
    G = as.numeric(counts["G"]),
    T = as.numeric(counts["T"])
  )
}))

# Display the resulting data frame
print(combined_df)


## 4-d
# Calculate the sum of each row and add it as a new column to the data frame
combined_df$Total <- rowSums(combined_df[, c("A", "C", "G", "T")])

# Adjust the max.print option dynamically based on the size of the data frame
options(max.print = nrow(combined_df) * ncol(combined_df))

# Print the entire data frame without truncation
print(combined_df, row.names = FALSE)


## 4-e
#4-e .1
# Expected sum for each list is 1000, except possibly the last chunk if the sequence length is not a multiple of 1000
expected_sum <- 1000

#4-e .2
# Identify lists whose sums differ from the expected value
expected_value <- 1000
discrepant_rows <- combined_df[combined_df$Total != expected_value, ]

# Print the rows with discrepancies, if any
if (nrow(discrepant_rows) > 0) {
  cat("The following kilobases have sums that differ from the expected value of", expected_value, ":\n")
  print(discrepant_rows)
} else {
  cat("All kilobase sums are equal to the expected value of", expected_value, ".\n")
}

#4-e .3
#In case some of the observed sums do not coincide with the expected values, it may be due to several causes:
Data Quality Issues: Errors during data collection or processing can lead to incorrect counts. This might include miscounts, missing values, or inaccuracies in data entry.
Biological Variability: Nucleotide composition can differ significantly across various biological samples. If the samples are heterogeneous, it can cause deviations from anticipated counts.
Sampling Bias: Using non-random or biased sampling methods can distort the data, producing unexpected results.
Technical Artifacts: Some biases can be introduced by sequencing technologies. For example, sequencing or PCR amplification errors may cause some overrepresentation of certain nucleotides.
Normalization Errors: If the data was not normalized properly, that would change the inflated or deflated counts for some nucleotides and cause discrepancies in the results.
